(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
      (global.jscalpel = factory());
}(this, (function () {
  'use strict';

  var jscalpel = function jscalpel(_ref, defaultOpts) {
    var target = _ref.target,
      keys = _ref.keys,
      prefix = _ref.prefix,
      callback = _ref.callback,
      deep = _ref.deep,
      dynamicKeys = _ref.dynamicKeys,
      plugins = _ref.plugins;

    var nativeToString = Object.prototype.toString;
    var enablePrefix = prefix ? true : false;



    var deepCopy = function deepCopy(obj) {
      var returnObj = {};
      var tempArr = [];
      if (nativeToString.call(obj) === '[object Object]') {
        Object.keys(obj).forEach(function (key, index) {
          if (Array.isArray(obj[key])) {
            obj[key].forEach(function (value, index) {
              tempArr.push(value);
            });
            returnObj[key] = tempArr;
            tempArr = [];
          } else if (nativeToString.call(obj[key] === '[object Object]')) {
            returnObj[key] = deepCopy(obj[key]);
          }
        });
        return returnObj;
      } else {
        return obj;
      }
    };



    var autoCompleteKey = function autoCompleteKey(key) {
      return '' + (prefix && enablePrefix ? prefix + '.' + key : '' + key);
    };



    var getParameterNames = function getParameterNames(fn) {
      console.log(fn.toString())
      var COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*\*\/))/mg;
      var FAT_ARROWS = /=>[\s\S]*/mg;
      var DEFAULT_PARAMS = /=[^,^\)]+/mg;
      
      
      var code = fn.toString().replace(COMMENTS, '')
      console.log('remove comments code: ', code)
      code = code.replace(FAT_ARROWS, '')
      console.log('removed arrow code: ', code)
      code = code.replace(DEFAULT_PARAMS, '');
      console.log('left the params code: ', code)

      var result = code.slice(code.indexOf('(') + 1, code.indexOf(')')).match(/([^\s,]+)/g);
      console.log('relaced: ', result)
      return result === null ? [] : result;
    };


    var getKeyPathValue = function (key, target, plugins) {
      // 优化: 如果检测到undefined直接跳出遍历
      let result = target
      let keysPaths = (autoCompleteKey(key)).split('.')
      console.log('keysPaths', keysPaths)
      for (let i = 0, len = keysPaths.length; i < len; i++) {
        result = result[keysPaths[i]]
        console.log('进来一次', result)
        if (result === undefined) break
      }
      // fixed: 获取到最终path信息，再进行插件操作
      let willPluginInfo = {
        value: result,
        name: key
      };
      console.log('willPluginInfo1: ', willPluginInfo)
      // 增加校验插件个数，另外这里不判断willPluginInfo.value，是因为即使value为undefined，也可能需要插件处理
      if (plugins && Array.isArray(plugins) && plugins.length) {
        plugins.forEach(function (plugin, index) {
          result = plugin(willPluginInfo);
        });
      }
      return result
    }


    var originalKeys = keys
    var epTarget = null;
    var cbParams = callback ? getParameterNames(callback) : [];
    console.log('cbParams', cbParams);



    if (typeof dynamicKeys === 'function') {
      keys = dynamicKeys(keys) || keys;
      // 有dynamicKeys时禁用prefix
      enablePrefix = false;
    }


    try {
      epTarget = typeof target === 'string' ? JSON.parse(target) : target;
      if (deep) {
        epTarget = deepCopy(epTarget);
      }

      if (nativeToString.call(epTarget) !== '[object Object]' && !Array.isArray(epTarget)) {
        throw new Error();
        return;
      }
    } catch (err) {
      console.error('传入的target不是有效的JSON或target不是Object/Array类型');
      return;
    }



    if (typeof keys === 'string' && keys.length > 0) {
      console.log('keys: ', autoCompleteKey(keys), autoCompleteKey(keys).split('.').length);
      // (autoCompleteKey(keys)).split('.').forEach(function (value, index) {
      //   result = result ? result[value] : epTarget[value];
      //   console.log('进来一次:', value, index, result)
      // });

      let result = getKeyPathValue(keys, epTarget, plugins)
      result = [result, epTarget, originalKeys, defaultOpts]

      if (callback && typeof callback === 'function') {
        return callback.apply(null, result) || result || defaultOpts;
      } else {
        return callback || result || defaultOpts
      }
    } else if (nativeToString.call(keys) === '[object Array]') {
      var pResult = [];
      keys.forEach(function (singlePath, idx) {
        let result = null;
        if (typeof singlePath === 'string') {
          // ('' + autoCompleteKey(singlePath)).split('.').forEach(function (value, index) {
          //   result = result ? result[value] : epTarget[value];
          // });

          let result = getKeyPathValue(singlePath, epTarget, plugins)
          pResult.push(result);
        }
      });


      pResult.push(epTarget, originalKeys, defaultOpts);

      let defaultValue = null
      if (callback && typeof callback === 'function') {
        defaultValue = callback.apply(null, pResult);
      } else {
        defaultValue = callback;
      }
      return defaultValue || pResult || defaultOpts;
    }
  };

  return jscalpel;

})));
//# sourceMappingURL=jscalpel.min.js.map

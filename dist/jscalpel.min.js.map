{"version":3,"file":"jscalpel.min.js","sources":["../index.js"],"sourcesContent":["const jscalpel = ({ target, keys, prefix, callback, deep, dynamicKeys, plugins}, defaultOpts) => {\r\n    const nativeToString = Object.prototype.toString;\r\n    let enablePrefix = prefix ? true : false;\r\n    const deepCopy = (obj) => {\r\n        const returnObj = {};\r\n        let tempArr = [];\r\n        if (nativeToString.call(obj) === '[object Object]') {\r\n            Object.keys(obj).forEach((key, index) => {\r\n                if (Array.isArray(obj[key])) {\r\n                    obj[key].forEach((value, index) => {\r\n                        tempArr.push(value);\r\n                    });\r\n                    returnObj[key] = tempArr;\r\n                    tempArr = [];\r\n                } else if (nativeToString.call(obj[key] === '[object Object]')) {\r\n                    returnObj[key] = deepCopy(obj[key]);\r\n                }\r\n            });\r\n            return returnObj;\r\n        } else {\r\n            return obj;\r\n        }\r\n    }\r\n    const autoCompleteKey = (key) => {\r\n        return (`${prefix && enablePrefix ? `${prefix}.${key}` : `${key}`}`);\r\n    } \r\n    let defaultValue = null;\r\n    let result = null;\r\n    let epTarget = null;\r\n    if (typeof dynamicKeys === 'function') {\r\n        keys = dynamicKeys(keys) || keys;\r\n        enablePrefix = false;\r\n    }\r\n    try {\r\n        epTarget = typeof target === 'string' ? JSON.parse(target) : target;\r\n        if (deep) {\r\n            epTarget = deepCopy(epTarget);\r\n        } \r\n        if (!nativeToString.call(epTarget) === '[object Object]') {\r\n            console.error('传入的target不是有效的json或者object');\r\n            return;\r\n        }\r\n    } catch (err) {\r\n        console.error('传入的target不是有效的json或者object');\r\n        return;\r\n    }\r\n    if (typeof keys === 'string' && keys.length > 0) {\r\n\r\n        `${autoCompleteKey(keys)}`.split('.').forEach((value, index) => {\r\n            result= (result ? result[value] : epTarget[value])\r\n            if (plugins && Array.isArray(plugins)) {\r\n                plugins.forEach((plugin, index) => {\r\n                    result = plugin(result);\r\n                })\r\n            }\r\n        })\r\n        if (callback && typeof callback === 'function') {;\r\n            defaultValue = callback.call(null, result, epTarget, keys, defaultOpts);\r\n        } else {\r\n            defaultValue = callback;\r\n        }\r\n        if (typeof defaultValue === 'undefined') {\r\n            return result || defaultOpts;\r\n        }\r\n        return defaultValue;\r\n    } else if (nativeToString.call(keys) === '[object Array]') {\r\n        const pResult = [];\r\n        keys.forEach((singlePath, index) => {\r\n            result = null;\r\n            if (typeof singlePath === 'string') {\r\n                `${autoCompleteKey(singlePath)}`.split('.').forEach((value, index) => {\r\n                    result= (result ? result[value] : epTarget[value])\r\n                    if (plugins && Array.isArray(plugins)) {\r\n                        plugins.forEach((plugin, index) => {\r\n                            result = plugin(result);\r\n                        })\r\n                    }\r\n                })\r\n                pResult.push(result);\r\n            }\r\n        })\r\n        pResult.push(epTarget,keys, defaultOpts);\r\n        if (callback && typeof callback === 'function') {\r\n            defaultValue = callback.apply(null, pResult);\r\n        } else {\r\n            defaultValue = callback;\r\n        }\r\n        if (typeof defaultValue === 'undefined') {\r\n            return pResult || defaultOpts;\r\n        }\r\n        return defaultValue;\r\n    }\r\n}\r\n\r\nexport default jscalpel;"],"names":["defaultOpts","target","keys","prefix","callback","deep","dynamicKeys","plugins","nativeToString","Object","prototype","toString","enablePrefix","autoCompleteKey","key","defaultValue","result","epTarget","JSON","parse","deepCopy","obj","returnObj","tempArr","call","forEach","index","Array","isArray","value","push","error","err","length","split","plugin","pResult","singlePath","apply"],"mappings":"2LAAiB,WAAgEA,OAA7DC,IAAAA,OAAQC,IAAAA,KAAMC,IAAAA,OAAQC,IAAAA,SAAUC,IAAAA,KAAMC,IAAAA,YAAaC,IAAAA,QAC7DC,EAAiBC,OAAOC,UAAUC,SACpCC,IAAeT,EAqBbU,EAAkB,SAACC,UACVX,GAAUS,EAAkBT,MAAUW,KAAWA,GAE5DC,EAAe,KACfC,EAAS,KACTC,EAAW,KACY,mBAAhBX,MACAA,EAAYJ,IAASA,KACb,YAGc,iBAAXD,EAAsBiB,KAAKC,MAAMlB,GAAUA,EACzDI,MAhCS,SAAXe,EAAYC,OACRC,KACFC,WAC6B,oBAA7Bf,EAAegB,KAAKH,WACbnB,KAAKmB,GAAKI,QAAQ,SAACX,EAAKY,GACvBC,MAAMC,QAAQP,EAAIP,OACdA,GAAKW,QAAQ,SAACI,EAAOH,KACbI,KAAKD,OAEPf,GAAOS,QAEVf,EAAegB,KAAkB,oBAAbH,EAAIP,QACrBA,GAAOM,EAASC,EAAIP,OAG/BQ,GAEAD,EAgBID,CAASH,IAEe,qBAAlCT,EAAegB,KAAKP,uBACbc,MAAM,8BAGpB,MAAOC,uBACGD,MAAM,iCAGE,iBAAT7B,GAAqBA,EAAK+B,OAAS,YAEvCpB,EAAgBX,IAAQgC,MAAM,KAAKT,QAAQ,SAACI,EAAOH,KACzCV,EAASA,EAAOa,GAASZ,EAASY,GACvCtB,GAAWoB,MAAMC,QAAQrB,MACjBkB,QAAQ,SAACU,EAAQT,KACZS,EAAOnB,YASA,OALxBZ,GAAgC,mBAAbA,EACJA,EAASoB,KAAK,KAAMR,EAAQC,EAAUf,EAAMF,GAE5CI,GAGRY,GAAUhB,EAEde,EACJ,GAAkC,mBAA9BP,EAAegB,KAAKtB,GAA4B,KACjDkC,cACDX,QAAQ,SAACY,EAAYX,KACb,KACiB,iBAAfW,QACJxB,EAAgBwB,IAAcH,MAAM,KAAKT,QAAQ,SAACI,EAAOH,KAC/CV,EAASA,EAAOa,GAASZ,EAASY,GACvCtB,GAAWoB,MAAMC,QAAQrB,MACjBkB,QAAQ,SAACU,EAAQT,KACZS,EAAOnB,SAIpBc,KAAKd,QAGbc,KAAKb,EAASf,EAAMF,QAMA,OALxBI,GAAgC,mBAAbA,EACJA,EAASkC,MAAM,KAAMF,GAErBhC,GAGRgC,GAAWpC,EAEfe"}